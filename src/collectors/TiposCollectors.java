package collectors;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.DoubleSummaryStatistics;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static java.util.stream.Collectors.*;

import java.util.ArrayList;


public class TiposCollectors {

	public static void main(String[] args) {
		List<String> givenList = Arrays.asList("a", "bb", "ccc", "dd");
		
		List<String> resultList = givenList.stream().collect(toList());
				
		Set<String> resultSet = givenList.stream().collect(toSet());
		
		List<String> resultLinkedList = givenList.stream().collect(toCollection(LinkedList::new));
		
		Map<String, Integer> s = givenList.stream().collect(toMap(Function.identity(), String::length));				
		
		Map<String, Long> g = givenList.stream().collect(groupingBy(Function.identity(), counting()));
		
		Map<String, Integer> identical = givenList.stream().collect(toMap(Function.identity(), String::length, (item, identicalItem) -> item));
		
		List<String> resultUpper = givenList.stream().map(p -> p.toUpperCase()).collect(Collectors.toList());
		
		List<String> resultThen = givenList.stream().collect(Collectors.collectingAndThen(toList(), convierte));
		
		String resultJoining = givenList.stream().collect(joining(" "));
		
		String resultJoiningPreFix = givenList.stream().collect(joining(" ", "PRE-", "-POST"));

		Long count = givenList.stream().collect(counting());
		
		DoubleSummaryStatistics statistics = givenList.stream().collect(summarizingDouble(String::length));
		
		Double averagingDouble = givenList.stream().collect(averagingDouble(String::length));
		
		Double averagingLong = givenList.stream().collect(averagingLong(String::length));
		Double averagingInt = givenList.stream().collect(averagingInt(String::length));
		
		Optional<String> maxBy = givenList.stream().collect(maxBy(Comparator.naturalOrder()));
		Optional<String> minBy = givenList.stream().collect(minBy(Comparator.naturalOrder()));
						
		Map<Integer, Set<String>> groupingBy = givenList.stream().collect(groupingBy(String::length, toSet()));
		
		Map<Boolean, List<String>> partitioningBy = givenList.stream().collect(partitioningBy(f -> f.length() > 2));
		
		List<Integer> numbers = Arrays.asList(42, 4, 2, 24);
		Optional<Integer> mini = numbers.stream().collect(minBy(Integer::compareTo));
		Optional<Integer> maxi = numbers.stream().collect(maxBy(Integer::compareTo));
	    
		String last1 = givenList.stream().reduce((h,k) -> k).orElse(null);
		String list2 = givenList.stream().skip(givenList.size()-1).findFirst().orElseGet(null);
		
		Optional<String> ss = Optional.of("test");
		String h =ss.map(String::toUpperCase).orElse(null);
		
		String l = ss.flatMap(sp -> Optional.of(sp.toUpperCase())).orElse(null);
		
		List<String> myList = givenList.stream().map(String::toUpperCase).collect(Collectors.toList());
		
		
		ArrayList<String> fruit = new ArrayList<>();
        fruit.add("Apple");
        fruit.add("mango");
        fruit.add("pineapple");
        fruit.add("kiwi");
        System.out.println("List of fruit-" + fruit);
       
        List<Integer> list = fruit.stream()
                        .map(String::length)
                        .collect(Collectors.toList());
        
        System.out.println("List generated by map-" + list);
		
		
        List<Integer> op = fruit.stream().mapToInt(p -> p.length()).boxed().collect(Collectors.toList());
        
        Predicate<String> predicate1 =  str -> str.startsWith("A");
        Predicate<String> predicate2 =  str -> str.length() > 4;
        
        List<String> result = fruit.stream()
          .filter(predicate1.and(predicate2))
          .collect(Collectors.toList());
        
        List<String> result2 = fruit.stream()
                .filter(str -> str.startsWith("A"))
                .filter(predicate2)
                .collect(Collectors.toList());
        
        List<String> result3 = fruit.stream()
        	      .filter(predicate1.or(predicate2.negate()))
        	      .collect(Collectors.toList());
        
        List<String> result4 = fruit.stream()
        	      .filter(
        	    		  ((Predicate<String>)name -> name.startsWith("A"))
        	    		  .and(name -> name.length()>4))
        	      .collect(Collectors.toList());

        List<Predicate<String>> allPredicates = new ArrayList<>();
        allPredicates.add(str -> str.startsWith("A"));
        allPredicates.add(str -> str.contains("p"));        
        allPredicates.add(str -> str.length() > 4);
        
        List<String> result5 = fruit.stream()
          .filter(allPredicates.stream().reduce(x -> false, Predicate::or))//.reduce(x->false, (p,lg) -> p.or(lg)))
          .collect(Collectors.toList());
        
        List<String> result6 = fruit.stream()
                .filter(allPredicates.stream().reduce(x -> true, Predicate::and))//.reduce(x->true, (p,lg) -> p.or(lg)))
                .collect(Collectors.toList());

        
		System.out.println();
	}		

	public static Function<List<String>, List<String>> convierte = (p -> {p.add("Procesada"); return p;});

}
